<?php
/*
 * This file is part of Ginger Workflow Framework.
 * (c) Alexander Miertsch <contact@prooph.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 * 
 * Date: 1/26/15 - 7:35 PM
 */
namespace SqlConnector\Service;

use Application\SharedKernel\DataLocation;
use Assert\Assertion;
use Doctrine\DBAL\Connection;
use Doctrine\DBAL\Schema\Column;
use Prooph\ServiceBus\CommandBus;

/**
 * Class TableConnectorGenerator
 *
 * Takes a sql table connector definition,
 * generates table row ginger types with the help of the doctrine dbal schema manager
 * and stores the definition in the ginger config.
 *
 * @package SqlConnector\Service
 * @author Alexander Miertsch <alexander.miertsch.extern@sixt.com>
 */
final class TableConnectorGenerator 
{
    const TAB = "    ";
    /**
     * @var CommandBus
     */
    private $commandBus;

    /**
     * @var DataLocation
     */
    private $dataLocation;

    /**
     * @var DbalConnectionCollection
     */
    private $dbalConnections;

    /**
     * @var array
     */
    private $doctrineGingerTypeMap;

    /**
     * @param DbalConnectionCollection $dbalConnections
     * @param DataLocation $dataLocation
     * @param CommandBus $commandBus
     * @param array $doctrineGingerTypeMap
     */
    public function __construct(
        DbalConnectionCollection $dbalConnections,
        DataLocation $dataLocation,
        CommandBus $commandBus,
        array $doctrineGingerTypeMap
    ) {
        $this->dbalConnections = $dbalConnections;
        $this->dataLocation = $dataLocation;
        $this->commandBus = $commandBus;
        $this->doctrineGingerTypeMap = $doctrineGingerTypeMap;
    }

    /**
     * @param string $id
     * @param array $connector
     * @throws \InvalidArgumentException
     */
    public function addConnector($id, array $connector)
    {
        $this->assertConnector($connector);

        if (! $this->dbalConnections->containsKey($connector['dbal_connection'])) {
            throw new \InvalidArgumentException(sprintf("Dbal connection %s for connector %s does not exists", $connector['dbal_connection'], $connector['name']));
        }

        $connection = $this->dbalConnections->get($connector['dbal_connection']);

        $this->generateGingerTypesIfNotExist($connection->config()['dbname'], $connector['table'], $connection->connection());
    }

    /**
     * @param array $connector
     */
    private function assertConnector(array $connector)
    {
        Assertion::keyExists($connector, "dbal_connection");
        Assertion::keyExists($connector, "table");
        Assertion::keyExists($connector, "name");
    }

    private function generateGingerTypesIfNotExist($dbname, $table, Connection $connection)
    {
        $dbNsName = $this->titleize($dbname);
        $className = $this->titleize($table);

        $path = $this->dataLocation->toString()
            . DIRECTORY_SEPARATOR . "SqlConnector"
            . DIRECTORY_SEPARATOR . "DataType"
            . DIRECTORY_SEPARATOR . $dbNsName
            . DIRECTORY_SEPARATOR . $className
            . ".php";

        if (file_exists($path)) return;

        $properties = $this->loadPropertiesForTable($table, $connection);
        $primaryKey = $this->loadPrimaryKeyforTable($table, $connection);
        $hasPrimaryKey = ($primaryKey)? "true" : "false";
        $primaryKeyStr = ($primaryKey)? '"' . $primaryKey . '"' : 'null';

        $gingerProperties = $this->propertiesToGingerPropString($properties);
        $doctrineTypeProperties = $this->propertiesToDoctrineTypeString($properties);
        $platformClassFQCN = get_class($connection->getDatabasePlatform());

        $classString = <<<TABLE_ROW
<?php
/*
 * This file was auto generated by SqlConnector\Service\TableConnectorGenerator.
 * (c) Alexander Miertsch <contact@prooph.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace SqlConnector\DataType\\{$dbNsName};

use Ginger\Type\Description\Description;
use Ginger\Type\Description\NativeType;
use SqlConnector\DataType\TableRow;

final class {$className} extends TableRow
{
    /**
     * @var array list of doctrine types indexed by property name
     */
    protected static \$propertyDbTypes = {$doctrineTypeProperties};

    /**
     * @var string Doctrine database platform class
     */
    protected static \$platformClass = '{$platformClassFQCN}';

    /**
     * @return array[propertyName => Prototype]
     */
    public static function getPropertyPrototypes()
    {
        return {$gingerProperties};
    }

    /**
     * @return Description
     */
    public static function buildDescription()
    {
        return new Description("Row", NativeType::DICTIONARY, {$hasPrimaryKey}, {$primaryKeyStr});
    }
}
TABLE_ROW;

        $dbNsDir = str_replace(DIRECTORY_SEPARATOR . $className . ".php", "", $path);

        if (! is_dir($dbNsDir)) mkdir($dbNsDir);

        file_put_contents($path, $classString);

    }

    private function loadPropertiesForTable($table, Connection $connection)
    {
        $columns = $connection->getSchemaManager()->listTableColumns($table);

        $props = [];

        foreach ($columns as $name => $column)
        {
            $gingerType = $this->doctrineColumnToGingerType($column);

            $props[$name] = [
                'ginger_type' => $gingerType,
                'doctrine_type' => $column->getType()->getName(),
            ];
        }

        return $props;
    }

    private function loadPrimaryKeyforTable($table, Connection $connection)
    {
        $indexes = $connection->getSchemaManager()->listTableIndexes($table);

        $primaryKey = null;

        foreach ($indexes as $index) {
            if ($index->isPrimary()) {
                $columns = $index->getColumns();

                $primaryKey = implode("_", $columns);
                break;
            }
        }

        return $primaryKey;
    }

    /**
     * @param Column $column
     * @throws \RuntimeException
     */
    private function doctrineColumnToGingerType(Column $column)
    {
        if (! isset($this->doctrineGingerTypeMap[$column->getType()->getName()])) {
            throw new \RuntimeException(sprintf("No ginger type mapping for doctrine type %s", $column->getType()->getName()));
        }

        $gingerType = $this->doctrineGingerTypeMap[$column->getType()->getName()];

        Assertion::implementsInterface($gingerType, 'Ginger\Type\Type');

        return $gingerType;
    }

    private function propertiesToGingerPropString(array $properties)
    {
        $propString = "[\n";

        foreach ($properties as $name => $propDef) {
            $propString.= self::TAB . self::TAB . self::TAB . "'" .$name . "' => \\" . $propDef['ginger_type'] . "::prototype(),\n";
        }

        $propString.= "\n" . self::TAB . self::TAB ."]";

        return $propString;
    }

    private function propertiesToDoctrineTypeString(array $properties)
    {
        $propString = "[\n";

        foreach ($properties as $name => $propDef) {
            $propString.= self::TAB . self::TAB . "'" .$name . "' => '" . $propDef['doctrine_type'] . "',\n";
        }

        $propString.= "\n" . self::TAB . "]";

        return $propString;
    }

    private function titleize($dbName)
    {
        $replace = ["_", "-"];
        $with = " ";
        return str_replace(" ", "", ucwords(str_replace($replace, $with, $dbName)));
    }
} 